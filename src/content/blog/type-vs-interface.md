---
title: 'Типы и интерфейсы'
description: 'Разбор общего и разного'
pubDate: 'Mar 16 2024'
heroImage: '/type-vs-interface-preview.png'
---

Я работаю руководителем направления клиентской разработки и временами нанимаю фронтендеров. Последний найм-марафон продлился чуть более месяца и я поговорил примерно с десятком кандидатов.

Во время этих всех собеседований я спрашивал у кандидатов в том числе и такой вопрос: 
— Когда ты используешь типы, а когда интерфейсы? 

Вроде бы простой выбор с которым каждый день десятки раз сталкивается разработчик. Но ответы заставили меня задуматься и пересмотреть свое отношение к этому вопросу.

Я обнаружил, что по ответу на этот вопрос можно с высокой вероятностью понять опыт кандидата. Если кандадат говорит, что для типизации пропсов в реактике он использует интерфейсы, то в большинстве случаев он начал использовать тайпскрипт еще когда реакт был на классах. Фронтендеры же новой школы поголовно всё типизируют типами. И с этим, в принципе, нет никаких проблем, кроме одной.

Ни те, ни другие не могут однозначно сказать на основе чего делают выбор. Поголовно это чисто интуитивное решение: из серии «прокатит — оставляем, не прокатило — переделываем». И их можно понять, эта схема работает довольно хорошо, зачем что-то менять. Но что я хочу услышать от кандидата?

Я не требую изложить мне всю теорию. Мне достаточно услышать хотя бы базовые три пункта:
— во многих случаях они взаимозаменяемы
— в библиотеках лучше экспортить интерфейсы, так как их можно расширить
— в тип можно записать любой существующий тип и не только.
Этого более чем достаточно, чтобы ответ меня устроил. Но я задумался, а знаю ли я сам ответ на этот вопрос на 100%?

Я полез в документацию и пропал. Мне кажется я раскопал столько всего странного и необычного, с чем не сталкивается типичный разработчик. И всё это только вокруг вопроса про базовые понятия типов и интерфейсов. Я сел записывать видео, начинал несколько раз, но каждый раз я понимал, что видео будет не полным, потому что вот есть еще такое и такое. А еще вот тут отличается. А еще и такую штуку можно делать. О Фи Ге Ть!


# Начинаем погружение! 

Путь предстоит долгий, поэтому нужно хорошенько подготовиться и вспомнить основы. Давайте на берегу вспомним как определяются интерфейсы и типы, в чем отличие и как все это дело связано.

Интерфейсы описывают объекты. Выглядит это следующим образом:

```typescript
interface AInt {
  first: boolean;
  second: number;
}
```

Здесь мы определили интерфейс с именем `AInt` и двумя полями: `first` и `second`. Надеюсь на этом этапе все понятно.

Такую же структуру объекта мы можем описать и с помощью типа:

```typescript
type AType = {
  first: boolean;
  second: number;
}
```

Обратите внимание, здесь мы использовали ключевое слово `type`, и после названия добавили знак `=`. Это первое отличие в синтаксисе. Но в остальном отличий нет.

Теперь мы можем создать объекты, которые будут соответствовать нашим `AInt` и `AType`:

```typescript
const aInt: AInt = {
  first: true,
  second: 10,
}

const aType: AType = {
  first: false,
  second: 42,
}
```

Как видите, разницы никакой. Более того, мы можем сделать функцию, которая принимает аргументы с типом `AInt` и подсунуть туда `aType`, код отработает без ошибок:

```typescript
function useInterface(param: AInt): void {
  console.log(param);
}

useInterface(aInt); // ошибки нет
useInterface(aType); // и здесь ошибки нет тоже
```

TypeScript использует механизм структурной типизации — cовместимость типов определяется на основе их структуры. Проще говоря: «выглядит как утка, крякает как утка, значит это утка», прямо как в JS. А вот в языках типа C# или Java такое не прокатит, потому что в них используется более строгая типизация — номинативная.

# Расширение

Цель этого блока — получить в результате описание объекта с тремя полями: `first`, `second` и `third`.

Давайте возьмем уже знакомые нам тип `AType` и интерфейс `AInt` и на их основе создадим новые.

Интерфейсы расширяются с помощью ключевого слова `extends`:
```typescript
interface BInt extends AInt {
  third: string;
}
```

С типами такую запись мы использовать не можем. Поэтому нам на помощь приходит инструмент «пересечение», который обозначается символом `&`. В результате мы получаем запись, которая с помощью выглядит иначе, но так же решает нашу задачу.
```typescript
type BType = AType & {
  third: string;
}
```

На этом можно было бы и закончить. Но не возник ли у вас вопрос, а можем ли мы применить ключевое слово `extends` к типу или `&` к интерфейсу? Давайте попробуем!
```typescript
interface BInt extends AType {
  third: string;
}
```

Внезапно! Эта запись работает! Получается, что интерфейсам в целом без разницы что расширять. Они одинаково хорошо расширят как и другой интерфейс, так и тип.

Что же с инструментом пересечения?
```typescript
type BType = AInt & {
  third: string;
}
```

Да, он тоже прекрасно работает как с интерфейсами, так и типами.

Более того, оказывается, мы можем использовать в качестве базы еще одну сущность — класс.

Для примера создадим класс с двумя полями: `first` и `second`.
```typescript
class AClass {
  public first: boolean;
  public second: number;

  constructor(x: boolean, y: number) {
    this.first = x;
    this.second = y;
  }
}
```

А теперь на его основе мы можем реализовать целевые тип и интерфейс:
```typescript
interface BInt extends AClass {
  third: string;
}

type BType = AClass & {
  third: string;
}
```

Трудно поверить, но все эти инструменты и варианты записи дают нам идентичный результат.

# Классы

Раз уж мы заговорили про классы, то давайте проясним и связанные с ними моменты.

Исторически так сложилось, что классы имплементируют, а простыми словами — реализуют, интерфейсы. Интерфейс является описанием, которому экземпляры класса должны соответствовать.

Сразу приведу пример: У нас есть уже наш давний знакомый интерфейс `AInt`, и его может имплементировать класс `CClass`. Выглядеть будет вот так:
```typescript
// Описываем интерфейс
interface AInt {
  first: boolean;
  second: number;
}

// Имплементируем
class CClass implements AInt {
  first = true;
  second = 20;
}

// Создаем экземпляр
const x = new CClass();
console.log(x.first); // true
```

А теперь интересно, сможем ли мы создать объект с другими значениями, ведь мы зафиксировали конкретные значения `first` и `second` в конструкторе. Пробуем:
```typescript
const a: CClass = {
  first: false;
  second: 15;
}

const b: AInt = {
  first: false;
  second: 15;
}
```
Да, все получилось! Класс в этом случае ведет себя так же как и интерфейс. Результаты идентичны.

А как поживает наш `type`? Думаю вы уже догадались. TypeScript настолько не различает `type` и `interface`, что готов имплементировать и `type` тоже.
```typescript
// Описываем тип
type AType {
  first: boolean;
  second: number;
}

// Имплементируем
class CClass implements AType {
  first = true;
  second = 20;
}

// Создаем экземпляр
const x = new CClass();
console.log(x.first); // true
```

Более того, чтобы показать, что TypeScript не видит разницы не только в типах и интерфейсах, но и в классах, я воспользуюсь в качестве основы уже знакомым нам классом `AClass`:
```typescript
// Описываем тип
class AClass {
  public first: boolean;
  public second: number;

  constructor(x: boolean, y: number) {
    this.first = x;
    this.second = y;
  }
}

// Имплементируем
class CClass implements AClass {
  first = true;
  second = 20;
}

// Создаем экземпляр
const x = new CClass();
console.log(x.first); // true
```

И здесь еще хочется добавить про расширение. Классы тоже умеют расширять типы, интерфейсы и другие классы. И да, у них тоже особенный синтаксис. Вот так можно добавить третье поле к `AInt` с помощью класса:
```typescript
class BClass implements AInt {
  public third: string;

  constructor() {
    this.first = true;
    this.second = 1;
    this.third = 'Hello';
  }
}
```

Расширять, как вы поняли, можно так же и `type`, и `class`. Но это я позволю вам попробовать сделать самостоятельно.

# Дженерики

Что такое дженерик? По факту — это инструмент языка TypeScript для описания структур данных, в которых тип каких-либо параметров стуктуры может задаваться из вне. Капец, хотел написать попроще, получилось посложнее. Дженерики в целом достойны отдельной статьи, здесь же разберем особенности в рамках сравнения типов и интерфейсов. 

Возьмем привычные нам `AInt` и `AType`, назовем их `DInt` и `DType` соответственно, и сделаем так, чтобы тип параметра `second` можно было задавать.
```typescript
// Определяем интерфейс
interface DInt<ExternalType> {
  first: boolean;
  second: ExternalType;
}

// Определяем тип
type DType<ExternalType> = {
  first: boolean;
  second: ExternalType;
}
```
Здесь мы создали переменную типа `ExternalType`. При создании константы с типом DInt или DType мы должны указывать тип, которому будет соответствовать параметр `second`. 

Если его не передать — будет ошибка. Если фактическое значение не будет совпадать с указанным, то тоже будет ошибка. Посмотрите:
```typescript
// Будет ошибка: Generic type 'DInt<ExternalType>' requires 1 type argument(s)
const dIntError: DInt = {
  first: true,
  second: 15,
}

// Так правильно
const dInt: DInt<number> = {
  first: true,
  second: 15,
} 

// Так будет ошибка: The expected type comes from property 'second' which is declared here on type 'DType<number>'
const dType: DType<number> = {
  first: true,
  second: 'bla bla',
}

// Так правильно
const dType: DType<string> = {
  first: true,
  second: 'bla bla',
}
```

На примерах видно, что определение и использование различается только на уровне определения ровно настолько, насколько в принципе различаются `type` и `interface`.

# Новая терминология

На просторах русскоязычного интернета не встречал, а вот в англоязычном интернете наткнулся на следующее разделение типов: псевдонимы, интерфейсы и классы. Это очень круто спасает, потому что у меня мозг взрывался когда я хотел написать «тип задаем с помощью типа, а тут тип задаем с помощью интерфейса» — получалась какая-то туфтология (от слова «туфта»).

Теперь все встало на свои места, и плюс можно сделать некоторые выводы:
1. Классы, интерфейсы и псевдонимы (они же алиасы) — это всё типы.
2. Тип можно описать с помощью класса. В этом случае получим все ништяки интерфейса и джаваскриптового класса.
3. Можно это сделать с помощью интерфейса. Тогда у типа будет своё имя и появится возможность расширяться.
4. А можно создать анонимный тип и сохранить его в переменную псевдонима. Именно поэтому у типов, созданных с помощью `type`, в отличие от созданных через `interface` нет имени в дебаггере, а выводится сразу структура. 

Из этих выводов вытекают следующие две темы: расширение интерфейсов и работа с псевдонимами.

О них поговорим далее.


Материал дописывается и обновляется. Подписывайся на обновления в [блоге в Telegram](https://t.me/+fcLS-3M_XSYxMDVi)