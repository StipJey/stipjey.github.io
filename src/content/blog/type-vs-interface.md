---
title: 'Типы и интерфейсы'
description: 'Разбор общего и разного'
pubDate: 'Mar 16 2024'
heroImage: '/type-vs-interface-preview.png'
---

Я работаю руководителем направления клиентской разработки и временами нанимаю фронтендеров. Последний найм-марафон продлился чуть более месяца и я поговорил примерно с десятком кандидатов.

Во время этих всех собеседований я спрашивал у кандидатов в том числе и такой вопрос: 
— Когда ты используешь типы, а когда интерфейсы? 

Вроде бы простой выбор с которым каждый день десятки раз сталкивается разработчик. Но ответы заставили меня задуматься и пересмотреть свое отношение к этому вопросу.

Я обнаружил, что по ответу на этот вопрос можно с высокой вероятностью понять опыт кандидата. Если кандадат говорит, что для типизации пропсов в реактике он использует интерфейсы, то в большинстве случаев он начал использовать тайпскрипт еще когда реакт был на классах. Фронтендеры же новой школы поголовно всё типизируют типами. И с этим, в принципе, нет никаких проблем, кроме одной.

Ни те, ни другие не могут однозначно сказать на основе чего делают выбор. Поголовно это чисто интуитивное решение: из серии «прокатит — оставляем, не прокатило — переделываем». И их можно понять, эта схема работает довольно хорошо, зачем что-то менять. Но что я хочу услышать от кандидата?

Я не требую изложить мне всю теорию. Мне достаточно услышать хотя бы базовые три пункта:
— во многих случаях они взаимозаменяемы
— в библиотеках лучше экспортить интерфейсы, так как их можно расширить
— в тип можно записать любой существующий тип и не только.
Этого более чем достаточно, чтобы ответ меня устроил. Но я задумался, а знаю ли я сам ответ на этот вопрос на 100%?

Я полез в документацию и пропал. Мне кажется я раскопал столько всего странного и необычного, с чем не сталкивается типичный разработчик. И всё это только вокруг вопроса про базовые понятия типов и интерфейсов. Я сел записывать видео, начинал несколько раз, но каждый раз я понимал, что видео будет не полным, потому что вот есть еще такое и такое. А еще вот тут отличается. А еще и такую штуку можно делать. О Фи Ге Ть!


# Начинаем погружение! 

Путь предстоит долгий, поэтому нужно хорошенько подготовиться и вспомнить основы. Давайте на берегу вспомним как определяются интерфейсы и типы, в чем отличие и как все это дело связано.

Интерфейсы описывают объекты. Выглядит это следующим образом:

```typescript
interface AInt {
  first: boolean;
  second: number;
}
```

Здесь мы определили интерфейс с именем `AInt` и двумя полями: `first` и `second`. Надеюсь на этом этапе все понятно.

Такую же структуру объекта мы можем описать и с помощью типа:

```typescript
type AType = {
  first: boolean;
  second: number;
}
```

Обратите внимание, здесь мы использовали ключевое слово `type`, и после названия добавили знак `=`. Это первое отличие в синтаксисе. Но в остальном отличий нет.

Теперь мы можем создать объекты, которые будут соответствовать нашим `AInt` и `AType`:

```typescript
const aInt: AInt = {
  first: true,
  second: 10,
}

const aType: AType = {
  first: false,
  second: 42,
}
```

Как видите, разницы никакой. Более того, мы можем сделать функцию, которая принимает аргументы с типом `AInt` и подсунуть туда `aType`, код отработает без ошибок:

```typescript
function useInterface(param: AInt): void {
  console.log(param);
}

useInterface(aInt); // ошибки нет
useInterface(aType); // и здесь ошибки нет тоже
```

TypeScript использует механизм структурной типизации — cовместимость типов определяется на основе их структуры. Проще говоря: «выглядит как утка, крякает как утка, значит это утка», прямо как в JS. А вот в языках типа C# или Java такое не прокатит, потому что в них используется более строгая типизация — номинативная.

# Расширение

Цель этого блока — получить в результате описание объекта с тремя полями: `first`, `second` и `third`.

Давайте возьмем уже знакомые нам тип `AType` и интерфейс `AInt` и на их основе создадим новые.

Интерфейсы расширяются с помощью ключевого слова `extends`:

```typescript
interface BInt extends AInt {
  third: string;
}
```

С типами такую запись мы использовать не можем. Поэтому нам на помощь приходит инструмент «пересечение», который обозначается символом `&`. В результате мы получаем запись, которая с помощью выглядит иначе, но так же решает нашу задачу.

```typescript
type BType = AType & {
  third: string;
}
```

На этом можно было бы и закончить. Но не возник ли у вас вопрос, а можем ли мы применить ключевое слово `extends` к типу или `&` к интерфейсу? Давайте попробуем!

```typescript
interface BInt extends AType {
  third: string;
}
```

Внезапно! Эта запись работает! Получается, что интерфейсам в целом без разницы что расширять. Они одинаково хорошо расширят как и другой интерфейс, так и тип.

Что же с инструментом пересечения?

```typescript
type BType = AInt & {
  third: string;
}
```

Да, он тоже прекрасно работает как с интерфейсами, так и типами.

Более того, оказывается, мы можем использовать в качестве базы еще одну сущность — класс.

Для примера создадим класс с двумя полями: `first` и `second`.

```typescript
class AClass {
  public first: boolean;
  public second: number;

  constructor(x: boolean, y: number) {
    this.first = x;
    this.second = y;
  }
}
```

А теперь на его основе мы можем реализовать целевые тип и интерфейс:

```typescript
interface BInt extends AClass {
  third: string;
}

type BType = AClass & {
  third: string;
}
```

Трудно поверить, но все эти инструменты и варианты записи дают нам идентичный результат.


---

Материал дописывается и обновляется. Подписывайся на обновления в [блоге в Telegram](https://t.me/+fcLS-3M_XSYxMDVi)